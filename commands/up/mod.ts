import { deploymentRuns, deployments } from "./../../api/deployments.ts";
import { command, Context, flag, flags, fmt } from "../../zcli.ts";
import { config } from "../../config.ts";
import { asserts } from "../../lib/asserts.ts";
import { loading } from "../../lib/loading.ts";
import { poll } from "../../lib/poll.ts";
import { AppError } from "../../errors.ts";
import { logger } from "../../logger.ts";
import { env } from "../../env.ts";
import * as appConfig from "../../lib/app-config.ts";
import { findProject } from "../../lib/find-project.ts";

/**
 * This variable is automatically generated by `zcli add`. Do not remove this
 * or change its name unless you're no longer using `zcli add`.
 */
const subCommands: ReturnType<typeof command>[] = [];

export const upFlags = flags({
  config: flag({
    aliases: ["c"],
    short:
      "The path to the config file. Defaults to our default config file paths.",
    long: `
      The path to the config file. Defaults to our default config file paths.

      The default config file paths are in order of precedence:

      - \`paperspace.yaml\`
      - \`paperspace.yml\`
      - \`paperspace.json\`
      - \`paperspace.jsonc\`
      - \`paperspace.toml\`
      - \`.paperspace/app.yaml\`
      - \`.paperspace/app.yml\`
      - \`.paperspace/app.json\`
      - \`.paperspace/app.jsonc\`
      - \`.paperspace/app.toml\`
    `,
  }).ostring(),
  "project-id": flag({
    aliases: ["p"],
    short: "The ID of the project to deploy to.",
  }).ostring(),
  cwd: flag({
    short:
      "The directory to deploy the app from. Defaults to the current directory.",
  }).ostring(),
});

export const up = command("up", {
  short: "Deploy your app to Paperspace",
  long: ({ root }) => `
    This will upsert an app config and deploy your app to Paperspace. You can optionally 
    specify a path to a config file. If no config file is specified, the default
    config file paths will be tried.

    Deploy the app in the current directory.
    \`\`\`
    $ ${root.name} up
    \`\`\`

    Deploy the app using a config file.
    \`\`\`
    $ ${root.name} up -c paperspace.json
    \`\`\`

    Deploy an app in a different directory.
    \`\`\`
    $ ${root.name} up --cwd ../my-app
    \`\`\`
  `,
  commands: subCommands,
  flags: upFlags,
  // We use command metadata in the `persistentPreRun` function to check if a
  // command requires an API key. If it does, we'll check to see if one is
  // set. If not, we'll throw an error.
  meta: {
    requireApiKey: true,
  },
}).run(
  async function* ({ flags, ctx }) {
    for await (const line of runUp({ flags, ctx })) {
      yield line;
    }
  },
);

export async function* runUp(
  { flags }: {
    flags: {
      cwd?: string;
      config?: string;
      "project-id"?: string;
      json?: boolean;
    };
    ctx: Context;
  },
) {
  const project = await findProject({
    quiet: !flags.json,
    cwd: flags.cwd,
    handle: flags["project-id"],
  });
  const configFile = await appConfig.find(flags);
  const team = await config.get("team");

  logger.info({ projectId: project.handle, config: configFile });
  const upsert = await loading(
    deployments.upsert({
      projectId: project.handle,
      config: configFile,
    }),
    { text: "Deploying", enabled: !flags.json },
  );

  asserts(upsert.ok, upsert);
  const { deploymentId } = upsert.data;
  const start = Date.now();

  asserts(upsert.ok, upsert);

  const { latestRun, deployment } = await loading(
    poll(async () => {
      const deployment = await deployments.get({ id: deploymentId! });

      if (
        deployment.ok && deployment.data.latestSpec?.externalApplied
      ) {
        if (
          !configFile.enabled ||
          ("resources" in configFile && configFile.resources.replicas === 0)
        ) {
          return {
            deployment: deployment.data,
            latestRun: { replicas: 0 },
          };
        }

        const runs = await deploymentRuns.get({ id: deploymentId! });

        if (runs.ok && runs.data) {
          const latestRun = runs.data[0];

          if (latestRun) {
            const erroredInstance = latestRun.instances.find(
              (instance) => ["failed", "errored"].includes(instance.state),
            );

            const timedOut = (Date.now() - start) > (5 * 60 * 1000);

            if (
              timedOut && latestRun.readyReplicas !== latestRun.replicas &&
              erroredInstance
            ) {
              throw new AppError({
                message:
                  `â›” ${
                    fmt.colors.bold("Deployment error")
                  }:\n${erroredInstance.stateMessage}` ?? "Deployment error",
                exitCode: 1,
              });
            }

            if (deployment.data.latestSpec?.dtHealthy) {
              return {
                deployment: deployment.data,
                latestRun: { replicas: latestRun.replicas },
              };
            }
          }
        }
      }
    }, "5s"),
    { text: "Waiting for ready status", enabled: !flags.json },
  );

  if (!flags.json) {
    if (latestRun.replicas) {
      yield `âœ¨ ${fmt.colors.bold("Your app is ready")}\n`;
      yield "   " + fmt.colors.bold("Console URL");
      yield "   " + new URL(
        `/${team}/projects/${project.handle}/gradient-deployments/${deployment.id}`,
        env.get("PAPERSPACE_CONSOLE_URL"),
      ).toString();
      yield "";
      yield "   " + fmt.colors.bold("Deployment URL");
      yield `   https://${deployment.endpoint}`;
    } else {
      yield `ðŸŒ™ ${fmt.colors.bold("Your app was disabled")}\n`;
      yield "   " + fmt.colors.bold("Console URL");
      yield "   " + new URL(
        `/${team}/projects/${project.handle}/gradient-deployments/${deployment.id}`,
        env.get("PAPERSPACE_CONSOLE_URL"),
      );
    }
  } else {
    yield JSON.stringify(deployment, null, 2);
  }
}
