import { deploymentRuns, deployments } from "./../../api/deployments.ts";
import { projects } from "./../../api/projects.ts";
import { command, flag, flags } from "../../zcli.ts";
import { config } from "../../config.ts";
import { asserts } from "../../lib/asserts.ts";
import { loading } from "../../lib/loading.ts";
import { poll } from "../../lib/poll.ts";
import { select } from "../../prompts/select.ts";
import { AppError, DocumentedError } from "../../errors.ts";
import { path, TOML, YAML } from "../../deps.ts";
import { paths } from "../../api/openapi.ts";
import { logger } from "../../logger.ts";
import { env } from "../../env.ts";

/**
 * This variable is automatically generated by `zcli add`. Do not remove this
 * or change its name unless you're no longer using `zcli add`.
 */
const subCommands: ReturnType<typeof command>[] = [];

export const up = command("up", {
  short: "Deploy your app to Paperspace",
  long: ({ root }) => `
    This will upsert an app config and deploy your app to Paperspace. You can optionally 
    specify a path to a config file. If no config file is specified, the default
    config file paths will be tried.

    Deploy the app in the current directory.
    \`\`\`
    $ ${root.name} up
    \`\`\`

    Deploy the app using a config file.
    \`\`\`
    $ ${root.name} up -c paperspace.json
    \`\`\`

    Deploy an app in a different directory.
    \`\`\`
    $ ${root.name} up --cwd ../my-app
    \`\`\`
  `,
  commands: subCommands,
  flags: flags({
    config: flag({
      aliases: ["c"],
      short:
        "The path to the config file. Defaults to our default config file paths.",
      long: `
        The path to the config file. Defaults to our default config file paths.

        The default config file paths are in order of precedence:

        - \`paperspace.yaml\`
        - \`paperspace.yml\`
        - \`paperspace.json\`
        - \`paperspace.toml\`
        - \`.paperspace/app.yaml\`
        - \`.paperspace/app.yml\`
        - \`.paperspace/app.json\`
        - \`.paperspace/app.toml\`
      `,
    }).ostring(),
    cwd: flag({
      short:
        "The directory to deploy the app from. Defaults to the current directory.",
    }).ostring(),
  }),
  // We use command metadata in the `persistentPreRun` function to check if a
  // command requires an API key. If it does, we'll check to see if one is
  // set. If not, we'll throw an error.
  meta: {
    requireApiKey: true,
  },
}).run(
  async function* ({ flags }) {
    const projectPath = flags.cwd
      ? path.isAbsolute(flags.cwd)
        ? flags.cwd
        : path.join(Deno.cwd(), flags.cwd)
      : Deno.cwd();
    const localProjects = await config.get("projects");
    let handle = localProjects[projectPath]?.handle;
    const configFile = await findAppConfig(projectPath, flags.config);
    const team = await config.get("team");

    if (!handle) {
      const existingProjects = await loading(projects.list({ limit: 50 }));
      asserts(existingProjects.ok, existingProjects);

      const selected = await select(
        "Select a project:",
        existingProjects.data.items,
        {
          renderOption(option, isSelected) {
            return `${isSelected ? ">" : " "} ${option.name}`;
          },
        },
      );

      asserts(selected, "No project selected.");
      handle = selected.handle;
    }

    logger.info({ projectId: handle, config: configFile });
    const upsert = await loading(
      // @ts-expect-error: it'll be ok
      deployments.upsert({ projectId: handle, config: configFile }),
      { text: "Deploying" },
    );

    asserts(upsert.ok, upsert);
    const { deploymentId } = upsert.data;

    asserts(upsert.ok, upsert);

    const { latestRun, deployment } = await loading(
      poll(async () => {
        const deployment = await deployments.get({ id: deploymentId! });

        if (
          deployment.ok && deployment.data.latestSpec?.externalApplied
        ) {
          if (
            !configFile.enabled ||
            ("resources" in configFile && configFile.resources.replicas === 0)
          ) {
            return {
              deployment: deployment.data,
              latestRun: { replicas: 0 },
            };
          }

          const runs = await deploymentRuns.get({ id: deploymentId! });

          if (runs.ok && runs.data) {
            const latestRun = runs.data[0];

            if (latestRun && latestRun.readyReplicas === latestRun.replicas) {
              return {
                deployment: deployment.data,
                latestRun: { replicas: latestRun.replicas },
              };
            }
          }
        }
      }, "5s"),
      { text: "Waiting for ready status" },
    );

    if (!flags.json) {
      if (latestRun.replicas) {
        yield `âœ¨ Your app is ready`;
        yield `  Console URL: ${new URL(
          `/${team}/projects/${handle}/gradient-deployments/${deployment.id}`,
          env.get("PAPERSPACE_CONSOLE_URL"),
        )}`;
        yield `  Deployment URL: https://${deployment.endpoint}`;
      } else {
        yield `ðŸ˜´ Your app was disabled`;
        yield `  Console URL: ${new URL(
          `/${team}/projects/${handle}/gradient-deployments/${deployment.id}`,
          env.get("PAPERSPACE_CONSOLE_URL"),
        )}`;
      }
    }
  },
);

async function findAppConfig(cwd: string, file?: string) {
  if (file) {
    logger.info(`Using config file: ${file}`);
    const filePath = path.isAbsolute(file) ? file : path.join(cwd, file);

    try {
      const config = await Deno.readTextFile(filePath);
      return parseConfig(filePath, config);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        throw new AppError({
          message: "No config file found at: " + filePath,
          exitCode: 1,
        });
      }

      throw err;
    }
  }

  logger.info(`No config file specified, searching for defaults.`);
  const configPaths = [
    "paperspace.yaml",
    "paperspace.yml",
    "paperspace.json",
    "paperspace.toml",
    ".paperspace/app.yaml",
    ".paperspace/app.yml",
    ".paperspace/app.json",
    ".paperspace/app.toml",
  ];

  for (const fileName of configPaths) {
    try {
      const cfg = path.join(cwd, fileName);
      logger.info(`  Attempting ${cfg}`);
      const config = await Deno.readTextFile(cfg);
      logger.info(`Found config file: ${cfg}`);
      return parseConfig(cfg, config);
    } catch (err) {
      if (err instanceof Deno.errors.NotFound) {
        continue;
      }

      throw err;
    }
  }

  throw new DocumentedError({
    message: "No Paperspace config file found.",
    path: "/deployments/config",
  });
}

function parseConfig(
  fileName: string,
  contents: string,
): paths["/deployments"]["post"]["requestBody"]["content"]["application/json"][
  "config"
] {
  const extname = path.extname(fileName);
  // @ts-expect-error: it's fine
  const parser = parsers[extname] ?? parsers[".yaml"];
  const result = parser(contents);
  delete result["$schema"];
  return result;
}

const parsers = {
  ".json": JSON.parse,
  ".yaml": YAML.parse,
  ".yml": YAML.parse,
  ".toml": TOML.parse,
};
