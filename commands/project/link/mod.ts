import { path } from "../../../deps.ts";
import { asserts } from "../../../lib/asserts.ts";
import { args, command, flag, flags, fmt, z } from "../../../zcli.ts";
import { projects } from "../../../api/projects.ts";
import { loading } from "../../../lib/loading.ts";
import { select } from "../../../prompts/select.ts";
import { AppError } from "../../../errors.ts";
import { config } from "../../../config.ts";

/**
 * This variable is automatically generated by `zcli add`. Do not remove this
 * or change its name unless you're no longer using `zcli add`.
 */
const subCommands: ReturnType<typeof command>[] = [];

export const link = command("link", {
  short: "Link a remote project to ",
  long: ({ root }) => `
    This will link a remote project to a local directory. Commands that
    depend on a project ID will use the project ID of the linked project
    when communicating with the Paperspace API.

    Link a project to the current directory.
    \`\`\`
    $ ${root.name} link
    \`\`\`

    Link a project to a different directory.
    \`\`\`
    $ ${root.name} link --cwd ../my-app
    \`\`\`

    Link a project and specify a project ID.
    \`\`\`
    $ ${root.name} link pzwf2g05ubegj
    \`\`\`
  `,
  commands: subCommands,
  args: args({
    short: "A project ID. If not provided, you will be prompted to select one.",
  }).tuple([z.string().describe("A project ID.")]).optional(),
  flags: flags({
    cwd: flag({
      short:
        "The directory to link the project to. Defaults to the current directory.",
    }).ostring(),
  }),
  // We use command metadata in the `persistentPreRun` function to check if a
  // command requires an API key. If it does, we'll check to see if one is
  // set. If not, we'll throw an error.
  meta: {
    requireApiKey: true,
  },
}).run(
  async function* ({ args, flags }) {
    const projectPath = !flags.cwd
      ? Deno.cwd()
      : path.isAbsolute(flags.cwd)
      ? flags.cwd
      : path.join(Deno.cwd(), flags.cwd);
    let [id] = args;
    const existingLinks = await config.get("projects");

    if (existingLinks[projectPath]) {
      const confirmed = confirm(
        "A project is already linked to this directory. Do you want to overwrite it?",
      );

      asserts(
        confirmed,
        new AppError({ message: "Project link not overwritten.", exitCode: 1 }),
      );
    }
    let projectName = "";

    if (!id) {
      const existingProjects = await loading(projects.list({ limit: 50 }), {
        enabled: !flags.json,
      });
      asserts(existingProjects.ok, existingProjects);

      const selected = await select(
        "Select a project:",
        existingProjects.data.items,
        {
          filter(input, option) {
            return option.name.toLowerCase().startsWith(input);
          },
          renderOption(option, isSelected) {
            return `${isSelected ? ">" : " "} ${option.name}`;
          },
        },
      );

      asserts(selected, "No project selected.");
      id = selected.id;
      projectName = selected.name;
    } else {
      const project = await loading(projects.get({ id }), {
        enabled: !flags.json,
      });
      asserts(project.ok, project);
      projectName = project.data.name;
    }

    await config.set("projects", {
      ...existingLinks,
      [projectPath]: {
        path: projectPath,
        id,
      },
    });

    yield `${fmt.colors.bold(projectName)} (${id}) linked to ${
      fmt.colors.bold(path.relative(Deno.cwd(), projectPath))
    }`;
  },
);
