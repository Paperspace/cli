import { storageProviders } from "../../../../api/storage-providers.ts";
import { fields } from "../../../../flags.ts";
import { asserts } from "../../../../lib/asserts.ts";
import { dataTable } from "../../../../lib/data-table.ts";
import { loading } from "../../../../lib/loading.ts";
import { pickJson } from "../../../../lib/pick-json.ts";
import { input } from "../../../../prompts/input.ts";
import { args, command, flag, flags, z } from "../../../../zcli.ts";
import { defaultFields } from "../../mod.ts";

/**
 * This variable is automatically generated by `zcli add`. Do not remove this
 * or change its name unless you're no longer using `zcli add`.
 */
const subCommands: ReturnType<typeof command>[] = [];

export const s3 = command("s3", {
  short: "Update an S3 storage provider",
  long: `
    Update an S3 storage provider in a project or team.
  `,
  commands: subCommands,
  args: args().tuple([
    z.string().describe("The ID of the storage provider to update"),
  ]).optional(),
  flags: flags({
    fields,
  }).merge(flags({
    "name": flag({
      aliases: ["n"],
      short: "The name of the storage provider",
    }).string(),
    "is-team-default": flag({
      short: "Whether the storage provider is the team's default provider",
    }).boolean(),
    "endpoint": flag({
      short: "The endpoint of the storage provider",
    }).ostring(),
    "bucket": flag({
      short: "The bucket of the storage provider",
    }).string(),
    "region": flag({
      short: "The region of the storage provider",
    }).ostring(),
    "access-key": flag({
      short: "The access key of the storage provider",
    }).string(),
    "secret-access-key": flag({
      short: "The secret access key of the storage provider",
    }).string(),
    "signature-version": flag({
      short: "The signature version of the storage provider",
    }).ostring(),
    "retain-data": flag({
      short: "Whether to retain data in the storage provider",
    }).oboolean(),
  })),
  // We use command metadata in the `persistentPreRun` function to check if a
  // command requires an API key. If it does, we'll check to see if one is
  // set. If not, we'll throw an error.
  meta: {
    requireApiKey: true,
  },
}).run(
  async function* ({ args, flags }) {
    let [id] = args;

    if (!id) {
      id = await input("ID:", {
        filter: (v) => !!v.sequence.match(/[a-zA-Z0-9_-]/),
      });
      asserts(id, "A storage provider ID is required");
    }

    const response = await loading(
      storageProviders.update({
        id,
        name: flags.name,
        isTeamDefault: flags["is-team-default"],
        s3Config: {
          endpoint: flags.endpoint,
          bucket: flags.bucket,
          region: flags.region,
          accessKey: flags["access-key"],
          secretAccessKey: flags["secret-access-key"],
          signatureVersion: flags["signature-version"],
          retainData: flags["retain-data"],
        },
      }),
    );

    asserts(response.ok, response);
    const result = response.data;

    if (flags.json) {
      yield pickJson(result, flags.fields);
    } else {
      for await (
        const line of dataTable([result], flags.fields ?? defaultFields)
      ) {
        yield line;
      }
    }
  },
);
