import { datasetVersions } from "../../../../api/dataset.ts";
import { datasets } from "../../../../api/dataset.ts";
import { fields } from "../../../../flags.ts";
import { asserts } from "../../../../lib/asserts.ts";
import { dataTable } from "../../../../lib/data-table.ts";
import { loading } from "../../../../lib/loading.ts";
import { pickJson } from "../../../../lib/pick-json.ts";
import { select } from "../../../../prompts/select.ts";
import { args, command, flag, flags, z } from "../../../../zcli.ts";
import { defaultFields } from "../mod.ts";

/**
 * This variable is automatically generated by `zcli add`. Do not remove this
 * or change its name unless you're no longer using `zcli add`.
 */
const subCommands: ReturnType<typeof command>[] = [];

export const update = command("update", {
  short: "Update a dataset version",
  long: `
    Update a dataset version in a project or team.
  `,
  commands: subCommands,
  args: args().tuple([
    z.string().describe("The ID of the dataset"),
    z.string().describe("The version of the dataset to update"),
  ]).optional(),
  flags: flags({
    fields,
  }).merge(flags({
    "message": flag({
      aliases: ["m"],
      short: "The description of the dataset version",
    }).string(),
    "tags": flag({
      short: "The tags for the version, comma-delimited",
    }).ostring(),
  })),
  // We use command metadata in the `persistentPreRun` function to check if a
  // command requires an API key. If it does, we'll check to see if one is
  // set. If not, we'll throw an error.
  meta: {
    requireApiKey: true,
  },
}).run(
  async function* ({ args, flags }) {
    let [datasetId, version] = args;

    if (!datasetId) {
      const existingProjects = await loading(datasets.list({ limit: 50 }), {
        enabled: !flags.json,
      });
      asserts(existingProjects.ok, existingProjects);

      const selected = await select(
        "Select a dataset:",
        existingProjects.data.items,
        {
          filter(input, option) {
            return (option.name ?? "").toLowerCase().startsWith(input);
          },
          renderOption(option, isSelected) {
            return `${isSelected ? ">" : " "} ${option.name ?? "(no name)"}`;
          },
        },
      );

      asserts(selected, "No dataset selected.");
      datasetId = selected.id;
    }

    if (!version) {
      const existingVersions = await loading(
        datasetVersions.list({ datasetId }),
        {
          enabled: !flags.json,
        },
      );
      asserts(existingVersions.ok, existingVersions);

      const selected = await select(
        "Select a dataset version:",
        existingVersions.data.items,
        {
          filter(input, option) {
            return (option.message ?? "").toLowerCase().startsWith(input);
          },
          renderOption(option, isSelected) {
            return `${isSelected ? ">" : " "} ${
              option.message ?? "(no description)"
            } [${option.version}]`;
          },
        },
      );

      asserts(selected, "No dataset version selected.");
      version = selected.version;
    }

    const response = await loading(
      datasetVersions.update({
        datasetId,
        version,
        message: flags.message,
        tags: flags.tags,
      }),
    );

    asserts(response.ok, response);
    const result = response.data;

    if (flags.json) {
      yield pickJson(result, flags.fields);
    } else {
      for await (
        const line of dataTable([result], flags.fields ?? defaultFields)
      ) {
        yield line;
      }
    }
  },
);
