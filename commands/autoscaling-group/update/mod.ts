import { asserts } from "../../../lib/asserts.ts";
import { loading } from "../../../lib/loading.ts";
import { args, command, flag, flags, z } from "../../../zcli.ts";
import { dataTable } from "../../../lib/data-table.ts";
import { fields } from "../../../flags.ts";
import { pickJson } from "../../../lib/pick-json.ts";
import { autoscalingGroups } from "../../../api/autoscaling-groups.ts";
import { input } from "../../../prompts/input.ts";

/**
 * This variable is automatically generated by `zcli add`. Do not remove this
 * or change its name unless you're no longer using `zcli add`.
 */
const subCommands: ReturnType<typeof command>[] = [];

export const update = command("update", {
  short: "Update an autoscaling group",
  long: `
    Update an autoscaling group.
  `,
  commands: subCommands,
  args: args().tuple([
    z.string().describe("The ID of the autoscaling group to get"),
  ]).optional(),
  flags: flags({
    fields,
  }).merge(flags({
    "name": flag({
      aliases: ["n"],
      short: "The name of the autoscaling group",
    }).ostring(),
    "cluster-id": flag({
      short: "The ID of the cluster",
    }).ostring(),
    "machine-type": flag({
      short: "The machine type for the autoscaling group",
    }).ostring(),
    "network-id": flag({
      short: "The ID of the network for the autoscaling group",
    }).ostring(),
    "template-id": flag({
      short: "The ID of the template for the autoscaling group",
    }).ostring(),
    "startup-script-id": flag({
      short: "The ID of the startup script for the autoscaling group",
    }).ostring(),
    "max": flag({
      short: "The maximum number of active machines in the autoscaling group",
    }).onumber(),
    "min": flag({
      short: "The minimum number of active machines in the autoscaling group",
    }).onumber(),
    "provisioning-timeout": flag({
      short:
        "The timeout for provisioning machines in the autoscaling group, in minutes",
    }).onumber(),
    "current": flag({
      short: "The desired number of active machines in the autoscaling group",
    }).onumber(),
  })),
  // We use command metadata in the `persistentPreRun` function to check if a
  // command requires an API key. If it does, we'll check to see if one is
  // set. If not, we'll throw an error.
  meta: {
    requireApiKey: true,
    requireInGoodStanding: true,
  },
}).run(
  async function* ({ args, flags }) {
    let [id] = args;

    if (!id) {
      id = await input("ID:", {
        filter: (v) => !!v.sequence.match(/[a-zA-Z0-9_-]/),
      });
      asserts(id, "An autoscaling group ID is required");
    }

    const response = await loading(
      autoscalingGroups.update({
        id,
        name: flags.name,
        clusterId: flags["cluster-id"],
        machineType: flags["machine-type"],
        networkId: flags["network-id"],
        templateId: flags["template-id"],
        max: flags.max,
        min: flags.min,
        current: flags.current,
        startupScriptId: flags["startup-script-id"],
        provisioningTimeout: flags["provisioning-timeout"],
      }),
    );

    asserts(response.ok, response);
    const result = response.data;

    if (flags.json) {
      yield pickJson(result, flags.fields);
    } else {
      for await (const line of dataTable([result], flags.fields)) {
        yield line;
      }
    }
  },
);
